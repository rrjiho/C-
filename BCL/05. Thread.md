## System.Threading.Thread
프로그램이 실행되면 주 스레드가 하나 기본적으로 생성된다. 주 스레드는 컴파일된 C# 코드를 순차적으로 실행해 나간다.  

```cs
static void Main(string[] args)
{
  Thread t = new Thread(threadFunc);
  t.Start();
  // 더는 주 스레드가 실행할 명령어가 없으므로 주 스레드는 제거됨
}

static void threadFunc()
{
  Console.WriteLine("60초 후 프로그램 종료");
  Thread.Sleep(1000 * 60);
  // 60초 동안 실행 중지
  // 현재 주 스레드는 종료됐어도 t 스레드는 존속함
  Console.WriteLine("스레드 종료");
}
```
- 정적 메서드 `Sleep`은 Running 상태인 스레드의 실행을 지정된 밀리초만큼 ThreadState.WaitSleepJoin 상태로 변경할 수 있다.

#### 만약 싱글스레드라면?
- 싱글 스레드 환경에서는 메인 스레드만 존재하므로, 메인 스레드가 `Thread.Sleep`에 의해 블로킹(blocking)되어 있는 동안, 프로그램은 60초 동안 아무 일도 하지 않고 멈춰 있다.  
#### 멀티스레드라면?
- 메인 스레드는 `Thread t = new Thread(threadFunc);`에서 새로운 스레드를 생성하고, `t.Start();`로 해당 스레드를 실행한다.
- 새로 생성된 스레드는 `threadFunc` 메서드를 실행하고, 그 안에서 "60초 후 프로그램 종료"를 출력한 후 `Thread.Sleep(1000 * 60)`로 60초 대기한다.
- 그 동안 메인 스레드는 `Thread.Sleep`에 의해 블로킹되지 않기 때문에, 새로운 스레드가 종료될 때까지 계속 실행을 계속할 수 있다.
- 60초가 지나면 `threadFunc` 안의 코드가 실행되어 "스레드 종료"가 출력된다.
- 만약 메인 스레드에서 별도의 명령이 있었다면 그것이 실행될 수 있다.

##### 마비노기는 모듈 및 입출력은 멀티스레드지만 게임 로직 처리는 싱글스레드라고 한다.
##### 따라서 클라이언트가 요청한 로직을 순차적으로 처리하기 때문에 병목현상이 발생하고 렉이 걸리는 현상이 생긴다.
##### 서버 구축 시 GameLogic 부분에서 lock을 걸었던 그 경험
##### 이를 위해 다음 프로젝트에서 멀티스레드로 제작한다고 한다.

## CPU 코어 - 프로세스 - 스레드
- 프로세스 (Process): 실행 중인 프로그램을 의미, 각 프로세스는 독립적인 메모리 공간을 가지고 있고 하나 이상의 스레드를 실행할 수 있다.
- 스레드 (Thread): 프로세스 내에서 실행되는 작업 단위, 하나의 프로세스는 기본적으로 주 스레드를 가지고 있으며 여러 부가적인 스레드도 만들 수 있다. 각 스레드는 독립적으로 실행되지만 같은 프로세스 내에서 메모리는 공유한다.
- CPU 코어 (Core): CPU 코어는 실제로 연산을 수행하는 물리적인 단위이다.

#### CPU 코어 하나 당 한 개의 스레드를 실행시키지만 => 하나씩 할당해서 사용하지만 여러 스레드를 빠르게 번갈아 가면서 사용할 수 있다.
#### 운영체제가 스레드 스케줄링을 담당하여 멀티코어 CPU에서 효율적인 작업 분배를 한다. 각 코어에 최적의 스레드를 분배하여 병렬 처리를 할 수 있도록 한다.

###### 이후 자세한 사용법은 서버 폴더에 따로 정리함.

